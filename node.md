# node

## 介绍一下 require 的模块加载机制

  1. 计算模块绝对路径；
  2. 如果缓存中有该模块，则从缓存中取出该模块
  3. 按优先级依次寻找并编译执行模块，将模块推入缓存（require.cache）中；
  4. 输出模块的 exports 属性；

## 请介绍一下 Node 中的内存泄露问题和解决方案

内存泄露原因

  1. 全局变量：全局变量挂在 root 对象上，不会被清除掉；
  2. 全局变量挂在 root 对象上，不会被清除掉；
  3. 事件监听：对同一个事件重复监听，忘记移除（removeListener），将造成内存泄露。

解决方案

  1. 最容易出现也是最难排查的就是事件监听造成的内存泄露，所以事件监听这块需要格外注意小心使用。
  2. 如果出现了内存泄露问题，需要检测内存使用情况，对内存泄露的位置进行定位，然后对对应的内存泄露代码进行修复。

## Node 更适合处理 I/O 密集型任务还是 CPU 密集型任务？为什么

  1. Node 更适合处理 I/O 密集型的任务。因为 Node 的 I/O 密集型任务可以异步调用，利用事件循环的处理能力，资源占用极少，并且事件循环能力避开了多线程的调用，在调用方面是单线程，内部处理其实是多线程的。
  2. 并且由于 Javascript 是单线程的原因，Node 不适合处理 CPU 密集型的任务，CPU 密集型的任务会导致 CPU 时间片不能释放，使得后续 I/O 无法发起，从而造成阻塞。但是可以利用到多进程的特点完成对一些 CPU 密集型任务的处理，不过由于 Javascript 并不支持多线程，所以在这方面的处理能力会弱于其他多线程语言（例如 Java、Go）

## 进程的当前工作目录是什么？有什么作用

  1. 进程的当前工作目录默认值是当前进程启动的目录，通过 process.cwd() 可以获取当前工作目录（current working directory），文件操作等使用相对路径时会相对当前工作目录来获取文件。
  2. 一些获取配置的第三方模块（例如 webpack）就是通过你的当前工作目录来获取对应的配置文件的，在程序中可以通过 process.chdir() 来改变当前的工作目录。

## 父进程或子进程的死亡是否会影响对方? 什么是孤儿进程

  1. 子进程死亡不会影响父进程，不过子进程死亡时，会向它的父进程发送死亡信号。反之父进程死亡，一般情况下子进程也会随之死亡，但如果此时子进程处于可运行状态、僵死状态等等的话，子进程将被 init 进程收养，从而成为孤儿进程。
  2. 另外，子进程死亡的时候（处于“终止状态”），父进程没有及时调用 wait() 或 waitpid() 来返回死亡进程的相关信息，此时子进程还有一个 PCB 残留在进程表中，被成为僵尸进程。
